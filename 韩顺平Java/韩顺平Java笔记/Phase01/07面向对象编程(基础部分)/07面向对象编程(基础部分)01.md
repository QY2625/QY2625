### 7.3 成员方法传参机制

#### 7.3.1基本数据类型的传参机制

【MethodParameter01.java】

Parameter 参数

1）看一个案例，分析结果是什么？

```java
public void swap(int a,int b){
  int temp = a;
  a = b;
  b = tmp;
  System.out.println("a="+a+"\tb="+b);
}
```

2）结论及示意图

​	基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参！

```java
public class MethodParameter01{
	public static void main(String[] args) {
		int a = 10;
		int b = 20;
		//创建AA对象
		AA obj = new AA();
		obj.swap(a,b);//调用swap

		System.out.println("main方法 a=" + a + " b=" + b);//a=10 b=20
	}
}

class AA{
	public void swap(int a,int b){
		System.out.println("\na和b交换之前的值a="+a+"\tb="+b);//a=10 b=20
		//完成了a 和 b 的交换
	    int temp = a;
	    a = b;
	    b = temp;
	    System.out.println("\na和b交换之后的值a="+a+"\tb="+b);//a=20 b=10
	}
}
```

<img src="07面向对象编程(基础部分)01.assets/image-20230915194448870.png" alt="image-20230915194448870" style="zoom: 50%;" />

#### 7.3.2用数据类型的传参机制

1）看一个案例 【MethodParameter02.java】

​	B 类中编写一个方法 test100， 可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化？会变化

​	B 类中编写一个方法 test200， 可以接收一个 Person(age,sal)对象， 在方法中修改该对象属性，看看原来的对象是否变化？会变化.

```java

public class MethodParameter02{
	public static void main(String[] args) {
		
		//测试
		B b = new B();
		// int[] arr = {1,2,3};
		// b.test100(arr);//调用方法

		// System.out.println(" mian的 arr数组");
		// //遍历数组
		// for (int i = 0;i < arr.length ;i++ ) {
		// 	System.out.print(arr[i]+" ");
		// }
		// System.out.println();

		//测试
		Person p = new Person();
		p.name = "jack";
		p.age = 10;

		b.test200(p);
		//测试，如果 test200 执行的是 p = null ，下面的结果是 10 
		//测试，如果 test200 执行的是 p = new Person();....,下面输出的结果是什么？
		System.out.println("main 的p.age=" + p.age);//10000
	}
}
class Person{
	String name;
	int age;
}
class B {

	public void test200(Person p){
		//p.age = 10000;//修改对象属性
		//思考
		p = new Person();
		p.name = "tom";
		p.age = 99;
		//思考
		//p = null;
	}

	//B 类中编写一个方法 test100， 
	//可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化？
	//
	public void test100(int[] arr){
		arr[0] = 200;
		//遍历数组
		System.out.println(" test100的 arr数组");
		for (int i = 0;i < arr.length ;i++ ) {
			System.out.print(arr[i]+" ");
		}
		System.out.println();
	}
}
```

2）结论及示意图

​	引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！

<img src="07面向对象编程(基础部分)01.assets/image-20230915201111209.png" alt="image-20230915201111209" style="zoom:50%;" />

<img src="07面向对象编程(基础部分)01.assets/image-20230915201137829.png" alt="image-20230915201137829" style="zoom:50%;" />

3）再看一个案例，下面的方法会对原来的对象有影响吗？

p=nill 和 p=new Person();对应示意图

<img src="07面向对象编程(基础部分)01.assets/image-20230915201308438.png" alt="image-20230915201308438" style="zoom:50%;" />

<img src="07面向对象编程(基础部分)01.assets/image-20230915201328145.png" alt="image-20230915201328145" style="zoom:50%;" />

#### 7.3.3 成员方法返回类型是引用类型应用实例

【MethodExercise02.java】

1）编写类 MyTools 类，编写一个方法可以打印二维数组的数据。

2）编写一个方法 copyPerson，可以复制一个 Person 对象，返回复制的对象。克隆对象， 注意要求得到新对象和原来的 对象是两个独立的对象，只是他们的属性相同

代码

```java
public class MethodExercise02{
	public static void main(String[] args) {
		
		Person p=new Person();
		p.name = "milan";
		p.age = 100;

		//创建tools
		MyTools tools = new MyTools();
		Person p2 = tools.copyPerson(p);

		//到此 p 和 p2 是Person对象，但是是两个独立的对象，属性相同
		System.out.println("p的属性 age="+ p.age + "名字" + p.name);
		System.out.println("p2的属性 age="+ p2.age + "名字" + p2.name);
		//提示：可以通过 通过对象比较看看是否为同一个对象
		System.out.println(p == p2);//false

	}
}

class Person{
	String name;
	int age;
}

class MyTools{
	//编写一个方法 copyPerson，可以复制一个 Person 对象，返回复制的对象。
	//克隆对象， 注意要求得到新对象和原来的 对象是两个独立的对象，只是他们的属性相同
	//
	//编写方法的思路
	//思路
	//1.方法的返回类型 Person
	//2.方法的名字 copyPerson
	//3.方法的形参 (Perosn p)
	//4.方法体,创建一个新对象，并复制属性，返回即可

	public Person copyPerson(Person p){
		//创建一个新的对象
		 Person p2= new Person();
		 p2.name = p.name;//把原来对象的名字赋给p2.name
		 p2.age = p.age;//把原来对象的年龄赋给p2.name
		 return p2;
	}
}
```

<img src="07面向对象编程(基础部分)01.assets/image-20230915212146513.png" alt="image-20230915212146513" style="zoom:50%;" />

### 7.4 方法递归调用

### 7.4.1基本介绍

简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变 得简洁

#### 7.4.2递归能解决什么问题？

1. 各种数学问题如：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题(google编程大赛)
2. 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等。
3. 将用栈解决的问题-->递归代码比较简洁